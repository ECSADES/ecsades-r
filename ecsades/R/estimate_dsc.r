#' Estimating the direct sampling contours
#'
#' @description
#' This function estimates the direct sampling contours with standardization, as proposed in Huesby et al. (2015), for a given
#' sample data or a fitted joint distribution of class \code{ht} or \code{wln} object.
#' 
#' @param object either a fitted joint distribution as generated by function \code{\link{fit_ht}}
#' and \code{\link{fit_wln}}, or an existing sample wave data containing \code{hs} and \code{tp} as columns. See details.
#' 
#' @param output_rp the required return periods (in years) for the estimated contours. 
#' 
#' @param npy the (optional) number of data points per year.  This argument is only needed if the input
#' \code{object} is a sample data set.
#' 
#' @param n_point the number of points to output around each contour. The default value is 100.
#' 
#' @details
#' The function can be applied to an existing sample data. To do this, the user needs
#' to supply both the sample data \code{sample_data} and the corresponding number of data points per year
#' \code{sample_data_npy}. The sample data can be generated using function \code{\link{sample_jdistr}} or otherwise, 
#' but must contain \code{hs} and \code{tp} as columns.  This \code{data.table} can also be generated
#' by reading a CSV file using function \code{\link[data.table]{fread}}.  
#' 
#' Alternatively this function can also be applied to a fitted joint distribution 
#' generated by function \code{\link{fit_ht}} or \code{\link{fit_wln}}.  When applied to a
#' \code{\link{fit_wln}} or \code{link{fit_ht}} object, the contour estimation makes use of the importance sampling
#' technique proposed in Huseby et. al. (2014) to improve the efficiency of the function.
#' 
#' @return A set of estimated environmental contours with the specified return periods in the format
#' of a \code{data.table} with \code{rp}, \code{hs}, and \code{tp} as columns.
#'
#' @seealso \code{\link{fit_ht}}, \code{\link{fit_wln}}, \code{\link{sample_jdistr}}, \code{\link{plot_ec}}
#' 
#' @examples
#' # Load data
#' data(ww3_pk)
#' 
#' # Estimate the DSC based on fitted Heffernan-Tawn model
#' ht = fit_ht(data = ww3_pk, npy = nrow(ww3_pk)/10, margin_thresh_count = 100, dep_thresh_count = 100)
#' dsc_ht = estimate_dsc(jdistr = ht, output_rp = c(1,10,100))
#' 
#' # Plot output
#' plot_ec(dsc_ht, ww3_pk)
#' 
#' # Estimate the DSC based on sample data
#' wln = fit_wln(data = ww3_pk, npy = nrow(ww3_pk)/10)
#' sample_data = sample_jdistr(jdistr = wln, sim_year = 1000)
#' dsc_data = estimate_dsc(sample_data = sample_data, sample_data_npy = nrow(sample_data)/1000, output_rp = c(1,10,100))
#' 
#' # Plot output
#' plot_ec(dsc_data, ww3_pk)
#' 
#' @references
#' Huseby, A., Vanem, E., Natvig, B., 2014. A new Monte Carlo method for environmental contour estimation.
#' Conference Proceedings. DOI:10.1201/b17399-286.
#' 
#' Huseby, A., Vanem, E., Natvig, B., 2015. Alternative environmental contours for structural reliability
#' analysis. Struct. Saf. 54, 32-45.
#' 
#' @export
estimate_dsc = function(object, output_rp, npy = NULL, n_point = 100){
  
  if("wln" %in% class(object)){
    
    res = .estimate_dsc_from_wln(wln = object, output_rp = output_rp, n_point = n_point)
    if(!is.null(npy)){
      warning("Argument npy will be imported from the provided joint distribution object.  The supplied npy is ignored.")
    }
    
  }else if("ht" %in% class(object)){
    
    res = .estimate_dsc_from_ht(ht = object, output_rp = output_rp, n_point = n_point)
    if(!is.null(npy)){
      warning("Argument npy will be imported from the provided joint distribution object.  The supplied npy is ignored.")
    }
    
  }else if("data.table" %in% class(object)){
    
    if(is.null(npy)){
      stop("Argument npy must be provided for estimating contours from sample data.")
    }
    res = cbind(
      rp=rep(output_rp, each=n_point+1),
      .estimate_dsc_from_data(sample_data = object, ex_prob = 1/output_rp/npy, n_point = n_point))
    
  }else{
    
    stop("The input object must be of class ht, wln or data.table.")
  }
  
  return(res)
}

.estimate_dsc_from_data = function(sample_data, ex_prob, n_point){
  
  ## Standardization
  ec_data = copy(sample_data)
  st_mu = colMeans(sample_data)
  st_sigma = apply(sample_data, 2, sd)
  st_rho = cor(ec_data)[1,2]
  ec_data[, hs:= (sample_data$hs-st_mu["hs"])/st_sigma["hs"]]
  ec_data[, tp:= ((sample_data$tp-st_mu["tp"])/st_sigma["tp"]-st_rho*hs)/sqrt(1-st_rho^2)]
  
  ## C_theta calculation
  theta = seq(0, 2*pi, length.out = n_point+1)
  d_theta = 2*pi/(n_point)
  calc = data.table(theta = theta, ex_prob = rep(ex_prob, each=n_point+1))
  calc[, c_theta:=quantile(cos(theta[1])*ec_data$tp+sin(theta[1])*ec_data$hs, 1-ex_prob, na.rm=T), .(theta)]
  calc[, c_theta_left:=c_theta[c(.N-1, 1:(.N-2), .N-1)], .(ex_prob)]
  calc[, c_theta_right:=c_theta[c(2:.N, 2)], .(ex_prob)]
  calc[, c_theta_prime:=(c_theta_right-c_theta_left)/(2*d_theta)]
  calc[, tp:=(c_theta*cos(theta)-c_theta_prime*sin(theta))]
  calc[, hs:=(c_theta_prime*cos(theta)+c_theta*sin(theta))]
  
  ## Rev-standardization
  st_data = calc[, .(hs, tp)]
  calc[, hs:=st_sigma["hs"]*st_data$hs+st_mu["hs"]]
  calc[, tp:=st_sigma["tp"]*(st_rho*st_data$hs+st_data$tp*sqrt(1-st_rho^2))+st_mu["tp"]]
  
  ## Return
  res = calc[, .(hs, tp)]
  
}

.estimate_dsc_from_wln = function(wln, output_rp, n_point){
  
  out_list = list()
  for(this_rp in output_rp){
    this_sample_data = .sample_wln_is(wln = wln, target_rp = this_rp)
    n_sim = round(wln$npy*this_rp*.target_rp_ub)
    tail_prob = 1/(this_rp*.target_rp_lb*wln$npy)
    min_r = qnorm(1-tail_prob)
    ex_prob = 1-(n_sim*(1-1/this_rp/wln$npy)-n_sim*(1-exp(-min_r^2/2)))/this_sample_data[,.N]
    out_list[[as.character(this_rp)]] = cbind(
      rp = this_rp,
      .estimate_dsc_from_data(sample_data = this_sample_data, ex_prob = ex_prob, n_point = n_point))
  }
  res = rbindlist(out_list)
  return(res)
}

.estimate_dsc_from_ht = function(ht, output_rp, n_point){
  
  out_list = list()
  for(this_rp in output_rp){
    this_sample_data = .sample_ht_is(ht = ht, target_rp = this_rp)
    n_sim = round(ht$npy*this_rp*.target_rp_ub)
    tail_prob = 1/(this_rp*.target_rp_lb*ht$npy)
    min_r = qnorm(1-tail_prob)
    ex_prob = 1-(n_sim*(1-1/this_rp/ht$npy)-n_sim*(1-exp(-min_r^2/2)))/this_sample_data[,.N]
    out_list[[as.character(this_rp)]] =  cbind(
      rp = this_rp, .estimate_dsc_from_data(
        sample_data = this_sample_data,
        ex_prob = ex_prob, n_point = n_point))
  }
  res = rbindlist(out_list)
  return(res)
}