#' Estimating the direct sampling (DSC) environmental contours
#'
#' @description
#' This function estimates the direct sampling (DSC) environmental contours with standardization, as proposed in Huesby et al. (2015),
#' for a given sample data set or a fitted joint distribution of class \code{ht} or \code{wln}.
#' 
#' @param object either a fitted joint distribution of class \code{wln} or \code{ht}, or an existing sample data
#' set containing \code{hs} and \code{tp} as columns. See details.
#' 
#' @param output_rp the required return periods (in years) for the estimated contours.
#' 
#' @param npy the (optional) number of data points per year. This argument is only needed if the input
#' \code{object} is a sample data set.
#' 
#' @param n_point the number of points to output around each contour. The default value is 100.
#' 
#' @details
#' The direct sampling contour is estimated in the origianl physical scales of \eqn{hs} and \eqn{tp} by direct
#' Monte Carlo simulations rather than applying the RosenBlatt transformation.
#' 
#' The function can be applied to an existing sample set, which can be generated by function \code{\link{sample_jdistr}}
#' or otherwise by importing a CSV file using function \code{\link[data.table]{fread}}. The input sample data
#' object must contain \code{hs} and \code{tp} as columns. The user must also specify the number of points per year
#' \code{npy} and a valid \code{output_rp}, i.e. the maximum \code{output_rp} must be shorter than the total
#' duration of the data set.
#' 
#' Alternatively this function can be applied to a fitted joint distribution object
#' generated by function \code{\link{fit_ht}} or \code{\link{fit_wln}}.  When applied to a
#' \code{wln} or \code{ht} object, the contour estimation makes use of the importance
#' sampling technique proposed in Huseby et. al. (2014) to improve the efficiency of the function.
#' 
#' @return
#' A set of estimated DSC contours with the specified return periods in the format
#' of a \code{data.table} with \code{rp}, \code{hs}, and \code{tp} as columns.
#' 
#' @examples
#' # Estimating DSC contours based on a fitted model
#' data(ww3_pk)
#' ht = fit_ht(data = ww3_pk, npy = nrow(ww3_pk)/10, margin_thresh_count = 50, dep_thresh_count = 500)
#' ec_ht = estimate_dsc(object = ht, output_rp = c(10,100,1000,10000))
#' plot_ec(ec = ec_ht, raw_data = ww3_pk)
#' 
#' # Estimating DSC contours based on a sample data set
#' data(ww3_ts)
#' ec_data = estimate_dsc(object = ww3_ts, output_rp = c(.5, 1, 2), npy = ww3_ts[, .N/10])
#' plot_ec(ec = ec_data, raw_data = ww3_ts)
#' 
#' @seealso \code{\link{fit_ht}}, \code{\link{fit_wln}}, \code{\link{sample_jdistr}}, \code{\link{plot_ec}}
#' 
#' @references
#' Huseby, A., Vanem, E., Natvig, B., 2014. A new Monte Carlo method for environmental contour estimation.
#' Conference Proceedings. DOI:10.1201/b17399-286.
#' 
#' Huseby, A., Vanem, E., Natvig, B., 2015. Alternative environmental contours for structural reliability
#' analysis. Struct. Saf. 54, 32-45.
#' 
#' @export
estimate_dsc = function(object, output_rp, npy = NULL, n_point = 100){
  
  if("wln" %in% class(object)){
    
    res = .estimate_dsc_from_wln(wln = object, output_rp = output_rp, n_point = n_point)
    if(!is.null(npy)){
      warning("Argument npy will be imported from the provided joint distribution object.  The supplied npy is ignored.")
    }
    
  }else if("ht" %in% class(object)){
    
    res = .estimate_dsc_from_ht(ht = object, output_rp = output_rp, n_point = n_point)
    if(!is.null(npy)){
      warning("Argument npy will be imported from the provided joint distribution object.  The supplied npy is ignored.")
    }
    
  }else if("data.table" %in% class(object)){
    
    if(is.null(npy)){
      stop("Argument npy must be provided for estimating contours from sample data.")
    }else{
      invalid_rp = output_rp[output_rp>object[, .N/npy]]
      if(length(invalid_rp)==length(output_rp)){
        stop("All output_rp values are invalid as they require extrapolation. Consider fitting a joint distribution first.")
      }else if(length(invalid_rp)>=1 & length(invalid_rp)<length(output_rp)){
        warning("Certain output_rp values are ignored as they requires extrapolation. Consider fitting a joint distribution first.") 
      }
      output_rp = setdiff(output_rp, invalid_rp)
    }
    
    res = cbind(
      rp=rep(output_rp, each=n_point+1),
      .estimate_dsc_from_data(sample_data = object, ex_prob = 1/output_rp/npy, n_point = n_point))
    
  }else{
    
    stop("The input object must be of class ht, wln or data.table.")
  }
  
  return(res)
}

.estimate_dsc_from_data = function(sample_data, ex_prob, n_point){
  
  ## Standardization
  ec_data = sample_data[, .(hs, tp)]
  st_mu = colMeans(ec_data)
  st_sigma = apply(ec_data, 2, sd)
  st_rho = cor(ec_data)[1,2]
  ec_data[, hs:= (sample_data$hs-st_mu["hs"])/st_sigma["hs"]]
  ec_data[, tp:= ((sample_data$tp-st_mu["tp"])/st_sigma["tp"]-st_rho*hs)/sqrt(1-st_rho^2)]
  
  ## C_theta calculation
  theta = seq(0, 2*pi, length.out = n_point+1)
  d_theta = 2*pi/(n_point)
  calc = data.table(theta = theta, ex_prob = rep(ex_prob, each=n_point+1))
  calc[, c_theta:=quantile(cos(theta[1])*ec_data$tp+sin(theta[1])*ec_data$hs, 1-ex_prob, na.rm=T), .(theta)]
  calc[, c_theta_left:=c_theta[c(.N-1, 1:(.N-2), .N-1)], .(ex_prob)]
  calc[, c_theta_right:=c_theta[c(2:.N, 2)], .(ex_prob)]
  calc[, c_theta_prime:=(c_theta_right-c_theta_left)/(2*d_theta)]
  calc[, tp:=(c_theta*cos(theta)-c_theta_prime*sin(theta))]
  calc[, hs:=(c_theta_prime*cos(theta)+c_theta*sin(theta))]
  
  ## Rev-standardization
  st_data = calc[, .(hs, tp)]
  calc[, hs:=st_sigma["hs"]*st_data$hs+st_mu["hs"]]
  calc[, tp:=st_sigma["tp"]*(st_rho*st_data$hs+st_data$tp*sqrt(1-st_rho^2))+st_mu["tp"]]
  
  ## Return
  res = calc[, .(hs, tp)]
  
}

.estimate_dsc_from_wln = function(wln, output_rp, n_point){
  
  out_list = list()
  for(this_rp in output_rp){
    this_sample_data = .sample_wln_is(wln = wln, target_rp = this_rp)
    n_sim = round(wln$npy*this_rp*.target_rp_ub)
    tail_prob = 1/(this_rp*.target_rp_lb*wln$npy)
    min_r = qnorm(1-tail_prob)
    ex_prob = 1-(n_sim*(1-1/this_rp/wln$npy)-n_sim*(1-exp(-min_r^2/2)))/this_sample_data[,.N]
    out_list[[as.character(this_rp)]] = cbind(
      rp = this_rp,
      .estimate_dsc_from_data(sample_data = this_sample_data, ex_prob = ex_prob, n_point = n_point))
  }
  res = rbindlist(out_list)
  return(res)
}

.estimate_dsc_from_ht = function(ht, output_rp, n_point){
  
  out_list = list()
  for(this_rp in output_rp){
    this_sample_data = .sample_ht_is(ht = ht, target_rp = this_rp)
    n_sim = round(ht$npy*this_rp*.target_rp_ub)
    tail_prob = 1/(this_rp*.target_rp_lb*ht$npy)
    min_r = qnorm(1-tail_prob)
    ex_prob = 1-(n_sim*(1-1/this_rp/ht$npy)-n_sim*(1-exp(-min_r^2/2)))/this_sample_data[,.N]
    out_list[[as.character(this_rp)]] =  cbind(
      rp = this_rp, .estimate_dsc_from_data(
        sample_data = this_sample_data,
        ex_prob = ex_prob, n_point = n_point))
  }
  res = rbindlist(out_list)
  return(res)
}