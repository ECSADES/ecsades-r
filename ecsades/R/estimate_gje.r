#' Estimating the generalised joint exceedance contours
#'
#' @description
#' This function estimates the generalised joint exceedance contours, as proposed in Jonathan et al. (2014), for a
#' given sample data or a fitted joint distribution of class \code{ht} or \code{wln} object.
#' 
#' @param object either a fitted joint distribution as generated by function \code{\link{fit_ht}}
#' and \code{\link{fit_wln}}, or an existing sample wave data containing \code{hs} and \code{tp} as columns. See details.
#' 
#' @param output_rp the required return periods (in years) for the estimated contours.
#' 
#' @param npy the (optional) number of data points per year.  This argument is only needed if the input
#' \code{object} is a sample data set.
#' 
#' @param n_point the number of points to output around each contour. The default value is 100.
#' 
#' @details
#' The function can be applied to an existing sample data. To do this, the user needs
#' to supply both the sample data \code{sample_data} and the corresponding number of data points per year
#' \code{sample_data_npy}. The sample data can be generated using function \code{\link{sample_jdistr}} or otherwise, 
#' but must contain \code{hs} and \code{tp} as columns.  This \code{data.table} can also be generated
#' by reading a CSV file using function \code{\link[data.table]{fread}}.  
#' 
#' Alternatively this function can also be applied to a fitted joint distribution 
#' generated by function \code{\link{fit_ht}} or \code{\link{fit_wln}}.  When applied to a
#' \code{\link{fit_wln}} or \code{link{fit_ht}} object, the contour estimation makes use of the importance
#' sampling technique proposed in Huseby et. al. (2014) to improve the efficiency of the function.
#' 
#' For each output return period \eqn{T}, the corresponding contour is a collection of points
#' \code{(hs, tp)} such that the joint exceedance probability \eqn{P(Hs>hs & Tp>tp)} or
#' \eqn{P(Hs>hs & Tp<tp)} is constant and equal to \eqn{1/T} for the upper or the lower part of the
#' contour respectively.
#' 
#' The \eqn{T}-year contour passes through an an anchor point \code{(hs0, tp0)} where \code{hs0} is the
#' (\eqn{T/2})-year wave heights, and \code{tp0} is the conditional median of the
#' wave period given the wave height is \code{hs0}.  The joint
#' exceedance probability for the upper and lower half of the contour is respectively
#' \deqn{P(Hs>hs0 & Tp>tp0) = P(Tp>tp0 | Hs>hs0)*P(Hs>hs0) = 0.5*(2/T) = 1/T}
#' \deqn{P(Hs>hs0 & Tp<tp0) = P(Tp<tp0 | Hs>hs0)*P(Hs>hs0) = 0.5*(2/T) = 1/T}
#' 
#' More generalised forms of reference points are to be implemented.
#' 
#' @return A set of estimated environmental contours with the specified return periods in the format
#' of a \code{data.table} with \code{rp}, \code{hs}, and \code{tp} as columns.
#'
#' @examples
#' # Load data
#' data(ww3_pk)
#' 
#' # Generate a 2000-year sample data based on fitted HT
#' ht = fit_ht(data = ww3_pk, npy = nrow(ww3_pk)/10, margin_thresh_count = 100, dep_thresh_count = 100)
#' n_sim_year = 2000
#' sample_data = sample_jdistr(jdistr = ht, sim_year = n_sim_year)
#' 
#' # Estimate the GJE contours using the default reference points
#' gje_data = estimate_gje(
#'   sample_data = sample_data,
#'   sample_data_npy = nrow(sample_data)/n_sim_year,
#'   output_rp = c(1, 10, 100))
#'   
#' # Plot output
#' plot_ec(gje_data, ww3_pk)
#' 
#' @references
#' Jonathan, P., Ewans, K., Flynn, J., 2014. On the estimation of ocean engineering design contours.
#' ASME J. Offshore Mech. Arct. Eng. 136:041101.
#' 
#' Huseby, A., Vanem, E., Natvig, B., 2014. A new Monte Carlo method for environmental contour estimation.
#' Conference Proceedings. DOI:10.1201/b17399-286.
#' 
#' @seealso \code{\link{fit_ht}}, \code{\link{fit_wln}}, \code{\link{sample_jdistr}}, \code{\link{plot_ec}}
#' 
#' @export
estimate_gje = function(
  object, output_rp, npy = NULL, n_point = 100){
  
  if("wln" %in% class(object)){
    
    res = .estimate_gje_from_wln(wln = object, output_rp = output_rp, n_point = n_point)
    
    if(!is.null(npy)){
      warning("Argument npy will be imported from the provided joint distribution object.  The supplied npy is ignored.")
    }
    
  }else if("ht" %in% class(object)){
    
    res = .estimate_gje_from_ht(ht = object, output_rp = output_rp, n_point = n_point)
    
    if(!is.null(npy)){
      warning("Argument npy will be imported from the provided joint distribution object.  The supplied npy is ignored.")
    }
    
  }else if("data.table" %in% class(object)){
    
    if(is.null(npy)){
      stop("Argument npy must be provided for estimating contours from sample data.")
    }
    
    res_list=list()
    for(this_rp in output_rp){
      res_list[[as.character(this_rp)]] = cbind(
        rp = this_rp,
        .estimate_gje_from_data(
          sample_data = object, n_jex = sample_data[,.N/npy]/this_rp,
          ap_hs = quantile(sample_data$hs, 1-2/npy/this_rp), n_point = n_point))
    }
    res = rbindlist(res_list)
    
  }else{
    
    stop("The input object must be of class ht, wln or data.table.")
  }
  
  return(res)
}


.estimate_gje_from_data = function(sample_data, n_jex, ap_hs, n_point){
  calc = data.table(hs1 = seq(ap_hs, min(sample_data$hs), length.out = ceiling((n_point+1)/2)))
  calc[, n_hs_tail:=sample_data[hs>=hs1, .N], .(hs1)]
  calc[, p_tp_upper:=1-n_jex/n_hs_tail]
  calc[, p_tp_lower:=n_jex/n_hs_tail]
  calc[, tp_upper:=sample_data[hs>=hs1, quantile(tp, p_tp_upper)], .(hs1)]
  calc[, tp_lower:=sample_data[hs>=hs1, quantile(tp, p_tp_lower)], .(hs1)]
  out = rbind(calc[.N:2, .(hs=hs1, tp=tp_upper)], calc[, .(hs=hs1, tp=tp_lower)])
  return(out)
}

.estimate_gje_from_wln = function(wln, output_rp, n_point){
  
  res_list=list()
  for(this_rp in output_rp){
    this_sample_data = .sample_wln_is(wln, target_rp=this_rp)
    this_out = .estimate_gje_from_data(
      sample_data = this_sample_data, n_jex = .target_rp_ub,
      ap_hs = qweibull(1-2/wln$npy/this_rp, shape = wln$hs$par["shape"], scale=wln$hs$par["scale"])+wln$hs$par["loc"],
      n_point = n_point)
    res_list[[as.character(this_rp)]] = cbind(rp=this_rp, this_out)
  }
  res = rbindlist(res_list)
  return(res)
}

.estimate_gje_from_ht = function(ht, output_rp, n_point){
  
  res_list=list()
  for(this_rp in output_rp){
    this_ap_hs = .convert_unif_to_origin(
      unif = 1-2/ht$npy/this_rp, p_thresh = ht$margin$p_margin_thresh,
      gpd_par = ht$margin$hs$par, emp = ht$margin$hs$emp)
    this_sample_data = .sample_ht_is(ht, target_rp=this_rp)
    this_out = .estimate_gje_from_data(
      sample_data = this_sample_data, n_jex = .target_rp_ub, ap_hs = this_ap_hs, n_point = n_point)
    res_list[[as.character(this_rp)]] = cbind(rp=this_rp, this_out)
  }
  res = rbindlist(res_list)
}

# .estimage_gje_from_data = function(sample_data, ex_prob, n_point){
#   
#   ## Main loop
#   res = list()
#   for(i in 1:length(output_rp)){
#     this_rp = output_rp[i]
#     
#     ## Define quadrants
#     sample_data[, ":="(c("qhs", "qtp"), list(abs(hs-ref_hs[i]), abs(ref_tp[i]-tp)))]
#     sample_data[hs>ref_hs[i] & tp>ref_tp[i], q:="hh"]
#     sample_data[hs>ref_hs[i] & tp<=ref_tp[i], q:="hl"]
#     sample_data[hs<=ref_hs[i] & tp>ref_tp[i], q:="lh"]
#     sample_data[hs<=ref_hs[i] & tp<=ref_tp[i], q:="ll"]
#     
#     ## Define contours per quadrant
#     target_prob = 1/(this_rp*npy)
#     target_n = target_prob*sample_data[, .N]
#     list_out = list()
#     n_q = sample_data[, uniqueN(q)]
#     
#     for(this_q in unique(sample_data$q)){
#       qdata = sample_data[q==this_q]
#       res_hs = lapply(
#         X = qdata[, seq(min(qhs), quantile(qhs, 1-target_prob), length.out=n_point/n_q)],
#         FUN = .find_gje_point_hs, target_n = target_n, qdata = qdata)
#       res_tp = lapply(
#         X = qdata[, seq(min(qhs), quantile(qtp, 1-target_prob), length.out=n_point/n_q)],
#         FUN = .find_gje_point_tp, target_n = target_n, qdata = qdata)
#       list_out[[this_q]] = cbind(rbind(rbindlist(res_hs), rbindlist(res_tp)), q=this_q)
#     }
#     this_out = cbind(rp=this_rp, rbindlist(list_out))
#     
#     ## Convert (qhs, qtp) to original hs, tp
#     this_out[q=="hh", ":="(c("hs", "tp"), list(qhs+ref_hs[i],qtp+ref_tp[i]))]
#     this_out[q=="hl", ":="(c("hs", "tp"), list(qhs+ref_hs[i],-qtp+ref_tp[i]))]
#     this_out[q=="lh", ":="(c("hs", "tp"), list(-qhs+ref_hs[i],qtp+ref_tp[i]))]
#     this_out[q=="ll", ":="(c("hs", "tp"), list(-qhs+ref_hs[i],-qtp+ref_tp[i]))]
#     this_out = this_out[sort.list(atan2(x=hs-ref_hs[i], y=tp-ref_tp[i]))]
#     res[[i]] = this_out
#   }
#   
#   ## Return
#   res = rbindlist(res)[,.(rp,hs,tp)]
#   return(res)
# }
# 
# .find_gje_point_hs = function(qhs0, target_n, qdata){
#   ub_n_qdata = qdata[, sum(qhs>qhs0)]
#   idx_valid = target_n<=ub_n_qdata
#   
#   qtp0 = qdata[qhs>qhs0, quantile(qtp, 1-target_n[idx_valid]/ub_n_qdata)]
#   res = data.table(qhs=rep(qhs0, sum(idx_valid)), qtp=qtp0)
#   return(res)
# }
# 
# .find_gje_point_tp = function(qtp0, target_n, qdata){
#   ub_n_qdata = qdata[, sum(qtp>qtp0)]
#   idx_valid = target_n<=ub_n_qdata
#   
#   qhs0 = qdata[qtp>qtp0, quantile(qhs, 1-target_n[idx_valid]/ub_n_qdata)]
#   res = data.table(qhs = qhs0, qtp=rep(qtp0, sum(idx_valid)))
#   return(res)
# }
# 
# 
