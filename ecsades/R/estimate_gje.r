#' Estimating the generalised joint exceedance contours
#'
#' @description
#' This function estimates the generalised joint exceedance contours, as proposed in Jonathan et al. (2014), for a
#' given sample data or a fitted joint distribution of class \code{ht} or \code{wln} object.
#' 
#' @param jdistr the (optional) fitted joint distribution as generated by function \code{\link{fit_ht}}
#' or \code{\link{fit_wln}}.  See details.
#' 
#' @param sample_data the (optional) existing sample wave data containing \code{hs} and \code{tp} as columns. See details.
#' 
#' @param sample_data_npy the (optional) number of data points per year of the sample data. See details.
#' 
#' @param output_rp the required return periods (in years) for the estimated contours. Note that return periods
#' that are substantially larger than the data coverage may lead to a long processing time.
#' 
#' @param n_point the number of points to output around each contour. The default value is 100.
#' 
#' @param ref_hs,ref_tp the wave height and wave period for the reference point(s). When either is
#' missing, the default reference points are \code{ref_hs = 0} and \code{ref_tp} equal to the median of the
#' conditional distribution of the wave period given the wave heights are above the
#' (\code{output_rp/2})-year return levels.  See details.
#' 
#' @details
#' The input \code{sample_data} must be a \code{data.table} object with \code{hs} and \code{tp} columns. This
#' can be generated by reading a CSV file using function \code{\link[data.table]{fread}}.
#' 
#' For each return period of the output contours, the corresponding reference point (\code{hs}, \code{tp})
#' divides the space into (up to) four quadrants.  The joint exceedance region of a given point is
#' then the corner formed by the point as the vertex, two semi-straight lines parallel to the \code{hs}
#' and \code{tp} axes respectively, and facing away from the reference point. Please refer to Jonathan et al.
#' (2014) for the mathematical formulation of the definition.
#' 
#' The default reference point will divide the space into two parts.  The resulting contour will pass
#' through a set of anchor points \code{(hs0, tp0)} where \code{hs0} is the (\code{output_rp/2})-year
#' return levels for wave heights, and \code{tp0 = ref_tp}.  The joint exceedance probability calculation
#' is therefore 
#' \deqn{P(Hs>hs0 & Tp>tp0) = P(Tp>tp0 | Hs>hs0)*P(Hs>hs0) = 0.5*(2/output_rp) = 1/output_rp}
#' \deqn{P(Hs>hs0 & Tp<tp0) = P(Tp<tp0 | Hs>hs0)*P(Hs>hs0) = 0.5*(2/output_rp) = 1/output_rp}
#' 
#' This function can be applied to either a fitted joint distribution of class \code{ht} or \code{wln}. This
#' happens when the user supplies a valid \code{ht} or \code{wln} object, and ignores arguments \code{sample_data}
#' and \code{sample_data_npy}.
#' 
#' This function can also be applied to an existing sample data. To do this, the user needs
#' to supply both the sample data \code{sample_data} and the corresponding number of data points per year
#' \code{sample_data_npy}. The sample data can be generated using function \code{\link{sample_jdistr}} or otherwise, 
#' but must contain \code{hs} and \code{tp} as columns.
#' 
#' Providing \code{sample_data} and \code{sample_data_npy} will make the input \code{jdistr} redundant.
#' 
#' @return A set of estimated environmental contours with the specified return periods in the format
#' of a \code{data.table} with \code{rp}, \code{hs}, and \code{tp} as columns.
#'
#' @examples
#' # Load data
#' data(ww3_pk)
#' 
#' # Generate a 2000-year sample data based on fitted HT
#' ht = fit_ht(data = ww3_pk, npy = nrow(ww3_pk)/10, margin_thresh_count = 100, dep_thresh_count = 100)
#' n_sim_year = 2000
#' sample_data = sample_jdistr(jdistr = ht, sim_year = n_sim_year)
#' 
#' # Estimate the GJE contours using the default reference points
#' gje_data = estimate_gje(
#'   sample_data = sample_data,
#'   sample_data_npy = nrow(sample_data)/n_sim_year,
#'   output_rp = c(1, 10, 100))
#'   
#' # Plot output
#' plot_ec(gje_data, ww3_pk)
#' 
#' @references
#' Jonathan, P., Ewans, K., Flynn, J., 2014. On the estimation of ocean engineering design contours.
#' ASME J. Offshore Mech. Arct. Eng. 136:041101.
#' 
#' @seealso \code{\link{fit_ht}}, \code{\link{fit_wln}}, \code{\link{sample_jdistr}}, \code{\link{plot_ec}}
#' 
#' @export
estimate_gje = function(
  jdistr, sample_data = NULL, sample_data_npy = NULL,
  output_rp, n_point = 100, ref_hs = NULL, ref_tp = NULL){
  
  ## Generate sample data
  if(is.null(sample_data)){
    sample_data = sample_jdistr(jdistr = jdistr, sim_year = max(output_rp)*.rp_multiplier)  
    npy = jdistr$npy
  }else{
    sample_data = copy(sample_data)
    npy = sample_data_npy
  }
  sample_data[, q:=NA_character_]
  
  ## Calculate ref
  if(is.null(ref_hs) || is.null(ref_tp)){
    n_sim_year = sample_data[,.N]/npy
    rl_hs = approx(
      x = log(n_sim_year/(1:nrow(sample_data))),
      y = sort(sample_data$hs, decreasing=T),
      xout = log(output_rp/2))$y
    ref_tp = c()
    for(i in 1:length(output_rp)){
      ref_tp[i] = sample_data[hs>rl_hs[i], median(tp)]
    }
    ref_hs = rep(0, length(output_rp))
  }else{
    ref_hs = rep(ref_hs, length.out = length(output_rp))
    ref_tp = rep(ref_tp, length.out = length(output_rp))
    if(length(output_rp)%%length(ref_hs)!=0 || length(output_rp)%%length(ref_tp)!=0){
      warning("The length of output_rp is not a multiple of the length of ref_hs or ref_tp.")
    }
  }
  
  ## Main loop
  res = list()
  for(i in 1:length(output_rp)){
    this_rp = output_rp[i]
    
    ## Define quadrants
    sample_data[, ":="(c("qhs", "qtp"), list(abs(hs-ref_hs[i]), abs(ref_tp[i]-tp)))]
    sample_data[hs>ref_hs[i] & tp>ref_tp[i], q:="hh"]
    sample_data[hs>ref_hs[i] & tp<=ref_tp[i], q:="hl"]
    sample_data[hs<=ref_hs[i] & tp>ref_tp[i], q:="lh"]
    sample_data[hs<=ref_hs[i] & tp<=ref_tp[i], q:="ll"]
    
    ## Define contours per quadrant
    target_prob = 1/(this_rp*npy)
    target_n = target_prob*sample_data[, .N]
    list_out = list()
    n_q = sample_data[, uniqueN(q)]
    
    for(this_q in unique(sample_data$q)){
      qdata = sample_data[q==this_q]
      res_hs = lapply(
        X = qdata[, seq(min(qhs), quantile(qhs, 1-target_prob), length.out=n_point/n_q)],
        FUN = .find_gje_point_hs, target_n = target_n, qdata = qdata)
      res_tp = lapply(
        X = qdata[, seq(min(qhs), quantile(qtp, 1-target_prob), length.out=n_point/n_q)],
        FUN = .find_gje_point_tp, target_n = target_n, qdata = qdata)
      list_out[[this_q]] = cbind(rbind(rbindlist(res_hs), rbindlist(res_tp)), q=this_q)
    }
    this_out = cbind(rp=this_rp, rbindlist(list_out))
    
    ## Convert (qhs, qtp) to original hs, tp
    this_out[q=="hh", ":="(c("hs", "tp"), list(qhs+ref_hs[i],qtp+ref_tp[i]))]
    this_out[q=="hl", ":="(c("hs", "tp"), list(qhs+ref_hs[i],-qtp+ref_tp[i]))]
    this_out[q=="lh", ":="(c("hs", "tp"), list(-qhs+ref_hs[i],qtp+ref_tp[i]))]
    this_out[q=="ll", ":="(c("hs", "tp"), list(-qhs+ref_hs[i],-qtp+ref_tp[i]))]
    this_out = this_out[sort.list(atan2(x=hs-ref_hs[i], y=tp-ref_tp[i]))]
    res[[i]] = this_out
  }
  
  ## Return
  res = rbindlist(res)[,.(rp,hs,tp)]
  return(res)
}

.find_gje_point_hs = function(qhs0, target_n, qdata){
  ub_n_qdata = qdata[, sum(qhs>qhs0)]
  idx_valid = target_n<=ub_n_qdata
  
  qtp0 = qdata[qhs>qhs0, quantile(qtp, 1-target_n[idx_valid]/ub_n_qdata)]
  res = data.table(qhs=rep(qhs0, sum(idx_valid)), qtp=qtp0)
  return(res)
}

.find_gje_point_tp = function(qtp0, target_n, qdata){
  ub_n_qdata = qdata[, sum(qtp>qtp0)]
  idx_valid = target_n<=ub_n_qdata
  
  qhs0 = qdata[qtp>qtp0, quantile(qhs, 1-target_n[idx_valid]/ub_n_qdata)]
  res = data.table(qhs = qhs0, qtp=rep(qtp0, sum(idx_valid)))
  return(res)
}


