#' Fitting Weibull-log-normal model to wave data
#'
#' @description 
#' This function fits a Weibull-log-normal (\code{wln}) model to the given wave data, such that the wave height
#' \code{hs} follows a translated (or 3-parameter) Weibull distribution, and the wave period given the wave
#' follows a conditional log-normal distributuion with the location and scale parameters as functions
#' of the corresponding \code{hs} value.
#' 
#' @param data the wave data in the form a \code{data.table} with wave height \code{hs} and wave period
#' \code{tp} as columns.
#' 
#' @param npy the number of data points per year, usually estimated by the number of rows in the
#' supplied wave data divided by the total period of data coverage (in years).
#' 
#' @param weibull_method the method for fitting the Weibull distribution to the \code{hs} column in the wave data. Choose
#' between \code{"lmom"} for L-moment or \code{"mle"} for maximum likelihood estimator. The default option
#' is \code{"lmom"}.
#' 
#' @details
#' The input \code{data} must be a \code{data.table} object with \code{hs} and \code{tp} columns. This can be
#' generated by reading a CSV file using function \code{\link[data.table]{fread}}.
#' 
#' The formulation of the conditional distribution is given by
#' \deqn{log(tp | hs=h) ~ N(\mu(h), \sigma(h)^2)}
#' where the mean and the standard deviation are
#' \deqn{\mu(h) = a_0 + a_1 h^a_2 and \sigma(h) = b_0 + b_1 exp(h * b_2)}
#' 
#' A two-step regression-based estimation method is used for fitting the conditional distribution of
#' \code{tp} given \code{hs}. The conditonal means and standard deviations are
#' estimated over fixed-width bands of \code{hs} in the first step, and regressed onto the above
#' functions of \code{hs} in the second step.
#' 
#' @return A joint distribution object of class \code{wln} containing the key information of a fitted
#' Weibull-log-normal model, including the three parameters of the Weibull distribution for \code{hs} (as a named
#' numeric vector) and the six parameters of the conditional log-normal distribution for \code{tp} given \code{hs}
#' (as an unamed numeric vector, in the order of \eqn{{a_0, a_1, a_2, b_0, b_1, b_2}}).
#'
#' It is possible to replace one or multiple \code{hs} or \code{tp} parameters in an existing \code{wln} object
#' (see the examples provided below). The current version of the package does not automatically check the
#' validity of these user-input parameters. Therefore users are advised to perform the check independently.
#' 
#' @examples
#' # Load data
#' data(ww3_pk)
#' 
#' # Fit Weibull-log-normal distribution 
#' wln1 = fit_wln(data = ww3_pk, npy = nrow(ww3_pk)/10, weibull_method = "mle")
#' 
#' # Fit Weibull-log-normal distribution using the alternative method
#' wln2 = fit_wln(data = ww3_pk, npy = nrow(ww3_pk)/10, weibull_method = "lmom")
#' 
#' # Update the hs parameters for object wln1
#' wln3 = copy(wln1)
#' wln3$hs$par[["loc"]] = 0.66
#' wln3$hs$par[["scale"]] = 2.2
#' wln3$hs$par[["shape"]] = 1.8
#'   
#' @references 
#' Haver, Sverre & Winterstein, Steven. (2009). Environmental Contour Lines: A Method for Estimating Long
#' Term Extremes by a Short Term Analysis. Transactions - Society of Naval Architects and Marine Engineers. 116. 
#' 
#' @seealso \code{\link{fit_ht}}, \code{\link{sample_jdistr}}
#' 
#' @export
fit_wln = function(data, npy, weibull_method="lmom"){
  
  res = list()
  class(res) = "wln"
  res$npy = npy
  res$hs = .fit_weibull(data = data$hs, weibull_method = weibull_method)
  res$tp = .fit_iform_lnorm(hs = data$hs, tp = data$tp)
  return(res)
}


# Conditional log-normal used for IFROM -----------------------------------

.fit_iform_lnorm = function(hs, tp){
  
  input_data = data.table(hs, tp)[sort.list(-hs)]
  mod_data = input_data[, .(log_mean=mean(log(tp)), log_sd=sd(log(tp))), .(hs=round(hs/.hs_res)*.hs_res)]
  
  mod_mean = nls(
    formula = log_mean~.cond_norm_mean(hs, a0, a1, a2), data = mod_data,  
    start = list(a0=1, a1=1, a2=.1), algorithm = "port", control = list(maxiter = 1e3, warnOnly=T))
  
  mod_sd = nls(
    formula = log_sd~.cond_norm_sd(hs, b0, b1, b2), data = mod_data, lower = c(0, 0, -Inf),
    start = list(b0=0.25, b1=0.1, b2=-0.1), algorithm = "port", control = list(maxiter = 1e3, warnOnly=T))
  
  res = list(par = c(coef(mod_mean), coef(mod_sd)))
  class(res) = "iform_lnorm"
  return(res)
}

.cond_norm_mean = function(hs, a0, a1, a2){
  a0+a1*hs^a2
}
.cond_norm_sd = function(hs, b0, b1, b2){
  b0+b1*exp(b2*hs)
}


# Weibull fit ----------------------------------------------------

.fit_weibull = function(data, weibull_method){
  res = list()
  
  if(weibull_method=="lmom"){
    out = as.numeric(lmom::pelwei(lmom::samlmu(data)))
    res$par = c(loc=out[1], scale=out[2], shape=out[3])
    res$conv = NA
  }else if(weibull_method=="mle"){
    theta0 = c(min(data-min(data))/2, sd(data), 1)
    op = nlminb(
      start = theta0,
      objective = .nll_weibull3, data = data,
      lower = c(.limit_zero, .limit_zero, .limit_zero),
      upper = c(min(data)-.limit_zero, .limit_inf, .limit_inf))
    res$par = c(loc=op$par[1], scale=op$par[2], shape=op$par[3])
    res$conv = op$convergence
  }else{
    stop("Only \"lmom\" and \"mle\" are supported.")
  }
  
  class(res) = "weibull"
  return(res)
}

.nll_weibull3 = function(theta, data) {
  if(theta[1]>=min(data) || theta[2]<=0 || theta[3]<=0){
    res = .limit_inf
  }else{
    nll = dweibull(data-theta[1], scale=theta[2], shape=theta[3], log = TRUE)
    res = -sum(nll)
  }
  return(res)
}