#' Estimating the isodensity contours
#'
#' @description
#' This function estimates the isodensity environmental contours for a fitted joint distribution of
#' class \code{ht} or \code{wln}.
#' 
#' @param object the fitted joint distribution object as generated by function \code{\link{fit_ht}}
#' or \code{\link{fit_wln}}.  See details.
#' 
#' @param output_rp the required return periods (in years) for the estimated contours. Note that return periods
#' that are substantially larger than the data coverage may lead to a long processing time
#' 
#' @param n_point the number of points to output around each contour. The default value is 100.
#' 
#' @details
#' The estimated contour for a given return period \code{rp} is a set of points with constant joint
#' probability density, equal to that at the anchor point.  The anchor point for the \eqn{K}-year return
#' period is the \eqn{K}-year return level on wave height \code{hs}, and the conditional median of
#' the wave period \code{tp}. See the guidance by DNV-GL section 3.7.2.
#' 
#' Due to the challenge of the non-parametric estimation of a joint denisty, the current version only
#' supports joint probability density estimation based on
#' the parametric form of the Weibull-log-normal model or the parametric part of the Heffernan-Tawn
#' model.  In particular, the residual distribution in the Heffernan-Tawn is approximted by a normal
#' distribution, rather than estimated using the kernel density.
#' 
#' For this same reason, the isodensity contour the function does not currently support inputs of
#' original sample data like the other contour estimation functions in this package.  Also when applied
#' to a Heffernan-Tawn \code{ht} class object, the quadrant below the dependence thresholds is ignored.
#' 
#' The users are always encouraged to choose a suitable joint distribution using \code{fit_ht} or
#' \code{fit_wln} and estimate the isodensity contours based on the fitted distribution.
#' 
#' @return A set of estimated environmental contours with the specified return periods in the format
#' of a \code{data.table} with \code{rp}, \code{hs}, and \code{tp} as columns.
#'
#' @examples
#' # Load data
#' data(ww3_pk)
#' data(ww3_ts)
#' 
#' # Draw isodensity contours using a ht fit on the full time series data
#' ht = fit_ht(data = ww3_ts, npy = nrow(ww3_ts)/10, 100, 500)
#' iso_ts = estimate_iso(object = ht,  output_rp = c(10, 100, 1000))
#' plot_ec(ec = iso_ts, raw_data = ww3_ts)
#' 
#' # Draw isodnesity contours using a wln fit on the peak data
#' wln = fit_wln(data = ww3_pk, npy = nrow(ww3_pk)/10)
#' iso_pk = estimate_iso(object = wln,  output_rp = c(1, 2, 5))
#' plot_ec(ec = iso_pk, raw_data = ww3_pk)
#' 
#' 
#' @seealso \code{\link{fit_ht}}, \code{\link{fit_wln}}, \code{\link{plot_ec}}
#' 
#' 
#' @references 
#' DNVGL-RP-C205, Recommended Practice - Environmental conditions and environmental loads,
#' Edition August 2017, https://rules.dnvgl.com/docs/pdf/DNVGL/RP/2017-08/DNVGL-RP-C205.pdf
#' 
#' @export
estimate_iso = function(object, output_rp, n_point=100){
  
  if("ht" %in% class(object)){
    
    res = .estimate_iso_from_ht(
      ht = object, output_rp = output_rp,
      n_point = n_point)
    
  }else if("wln" %in% class(object)){
    
    res = .estimate_iso_from_wln(
      wln = object, output_rp = output_rp,
      n_point = n_point)
    
  }else if("data.table" %in% class(object)){
    
    stop("Estimation of the isodensity contours based on sample data is not currently supported. Please consider
         the alternative types of contours or fitting a Weibull-log-normal or Heffernan-Tawn distribtuion to 
         the data set first.")
    
  }else{
    
    stop("The input object must be of class ht or wln.")
  }
  return(res)
}



# Estimate the contour based on a formulated wln --------------------------

.estimate_iso_from_wln = function(wln, output_rp, n_point, ...){
  
  ## Anchor point log-density
  hs_par = wln$hs$par
  tp_par = wln$tp$par
  prob_hs = 1-1/(output_rp*wln$npy)
  hs0 = qweibull(p = prob_hs, shape = hs_par[["shape"]], scale = hs_par[["scale"]])+hs_par[["loc"]]
  tp0 = exp(tp_par[1] + tp_par[2] * hs0^tp_par[3])
  ld0 = .ldwln(hs0, tp0, hs_par, tp_par)
  hs_max = log((-tp_par[4]+.limit_zero)/tp_par[5])/tp_par[6]

  ## Main loop
  res_list = list()
  for(i in 1:length(output_rp)){
    
    ### Identify ranges of hs
    this_hs_range = .find_hs_range_given_ldwln(
      target_ldwln = ld0[i], hs_par = hs_par, tp_par = tp_par, hs_max = hs_max, hs_rl = hs0[i])
    this_calc = data.table(hs = seq(this_hs_range[1], this_hs_range[2], length.out = round(n_point/2)+1))
    
    ### Find the corresponding tp
    this_calc[, mean_log:=tp_par[1] + tp_par[2] * (hs^tp_par[3])]
    this_calc[, var_log:=tp_par[4] + tp_par[5] * exp(tp_par[6] * hs)]
    this_calc[, ld_hs:=log(dweibull(hs-hs_par[["loc"]], shape=hs_par[["shape"]], scale=hs_par[["scale"]]))]
    this_calc[, ld_tp:=ld0[i]-ld_hs]
    for(i_row in 1:this_calc[,.N]){
      i_tp_range = this_calc[i_row, .find_tp_given_ldtp(ld_tp, mean_log, var_log)]
      this_calc[i_row, tp_lb:=i_tp_range[1]]
      this_calc[i_row, tp_ub:=i_tp_range[2]]
    }
    
    ### Return
    res_list[[i]] = this_calc[, .(
      rp = output_rp[i],
      hs = hs[c(1:(.N-1), .N:2)],
      tp = c(tp_lb[1]/2+tp_ub[1]/2, tp_lb[2:(.N-1)], tp_ub[.N]/2+tp_lb[.N]/2, tp_ub[(.N-1):2]))]
  }
  
  ## Return
  res = rbindlist(res_list)
  return(res)
}

.ldwln = function(hs, tp, hs_par, tp_par){
  f_hs = dweibull(hs-hs_par[["loc"]], shape=hs_par[["shape"]], scale=hs_par[["scale"]])
  mean_log = tp_par[1] + tp_par[2] * (hs^tp_par[3])
  var_log = tp_par[4] + tp_par[5] * exp(tp_par[6] * hs)
  f_tp_hs = dlnorm(tp, meanlog = mean_log, sdlog = sqrt(var_log))
  return(log(f_hs)+log(f_tp_hs))
}

.find_max_ldwln_given_hs = function(hs, hs_par, tp_par){
  mean_log = tp_par[1] + tp_par[2] * (hs^tp_par[3])
  var_log = tp_par[4] + tp_par[5] * exp(tp_par[6] * hs)
  tp_mode = exp(mean_log-var_log)
  return(.ldwln(hs, tp_mode, hs_par, tp_par))
}

.find_hs_range_given_ldwln = function(target_ldwln, hs_par, tp_par, hs_max, hs_rl){
  op_fn = function(hs, hs_par, tp_par)(.find_max_ldwln_given_hs(hs, hs_par, tp_par)-target_ldwln-.limit_zero)^2
  op1 = optim(
    par = hs_rl/4, fn = op_fn, hs_par=hs_par, tp_par=tp_par, method = "Brent",
    lower = .limit_zero, upper = hs_rl/2)
  op2 = optim(
    par = hs_rl, fn = op_fn, hs_par=hs_par, tp_par=tp_par, method = "Brent",
    lower = hs_rl/2, upper = hs_max)
  c(op1$par, op2$par)
}

.find_tp_given_ldtp = function(target_ldtp, mean_log, var_log){
  op_fn = function(tp, target_ldtp, mean_log, var_log)
    (log(dlnorm(tp, meanlog = mean_log, sdlog = sqrt(var_log)))-target_ldtp)^2
  op1 = optim(
    par = .limit_zero, fn = op_fn,
    mean_log=mean_log, var_log=var_log, target_ldtp = target_ldtp,
    method = "Brent", lower = .limit_zero, upper = exp(mean_log-var_log))
  op2 = optim(
    par = exp(mean_log-var_log), fn = op_fn,
    mean_log=mean_log, var_log=var_log, target_ldtp = target_ldtp,
    method = "Brent", lower = exp(mean_log-var_log), upper =  exp(mean_log-var_log)*100)
  return(c(op1$par, op2$par))
}



# Esimate the contour based on a formulated ht ----------------------------

.estimate_iso_from_ht = function(ht, output_rp, n_point){
  
  ## Find anchro points
  ap = .find_ht_iso_anchor_points(ht, output_rp)

  ## Calculate density on lap_grid exceedance area only
  lap_thresh = -log(2-2*ht$dep$p_dep_thresh)
  max_lap = -2*log(2-2*(1-1/max(output_rp)/ht$npy))
  dlap = (max_lap-lap_thresh)/max(100,n_point)
  range_lap = seq(max_lap, by = -dlap, to = -max_lap)
  grid_lap = data.table(
    lap_hs = range_lap, lap_tp = rep(range_lap, each=length(range_lap)))
  setkey(grid_lap, lap_hs, lap_tp)
  ld_calc = .ld_ht(dt_lap = grid_lap[, .(lap_hs, lap_tp)], ht = ht)
  grid_lap = merge(grid_lap, ld_calc, by = c("lap_hs", "lap_tp"))
  
  ## Draw contours
  mat = as.matrix(dcast.data.table(grid_lap, lap_hs~lap_tp, value.var = "ld")[,-1,with=F])
  cl = contourLines(
    x = sort(range_lap), y = sort(range_lap),
    z = mat, levels = ap$ld)
  res = rbindlist(lapply(cl, function(x)data.table(ld=x$level, lap_hs=x$x, lap_tp=x$y)))
  
  ## Convert contour to original scale
  res[, u_hs:=(.5+sign(lap_hs)/2)-sign(lap_hs)/2*exp(-abs(lap_hs))]
  res[, u_tp:=(.5+sign(lap_tp)/2)-sign(lap_tp)/2*exp(-abs(lap_tp))]
  n = length(ht$margin$hs$emp)
  res[, hs:=quantile(ht$margin$hs$emp, u_hs)]
  res[u_hs>ht$margin$p_margin_thresh, u_gpd:=(u_hs-ht$margin$p_margin_thresh)/(1-ht$margin$p_margin_thresh)]
  res[u_hs>ht$margin$p_margin_thresh, hs:=evd::qgpd(
    p = u_gpd, loc = ht$margin$hs$par[1],
    scale = ht$margin$hs$par[2], shape = ht$margin$hs$par[3])]
  res[, u_gpd:=NULL]
  res[, tp:=quantile(ht$margin$tp$emp, u_tp)]
  res[u_tp>ht$margin$p_margin_thresh, u_gpd:=(u_tp-ht$margin$p_margin_thresh)/(1-ht$margin$p_margin_thresh)]
  res[u_tp>ht$margin$p_margin_thresh, tp:=evd::qgpd(
    p = u_gpd, loc = ht$margin$tp$par[1],
    scale = ht$margin$tp$par[2], shape = ht$margin$tp$par[3])]
  res[, angle:=atan2(y = lap_tp, x = lap_hs)/pi*180]
  
  ## Refine output contour
  contour = merge(res[, .(ld, hs, tp, angle)], ap[, .(ld, rp)], by = "ld")[, .(rp, hs, tp, angle)]
  setkey(contour, rp, angle)
  out = contour[, .SD[round(seq(1, .N, length.out = n_point))], .(rp)]
  
  ## Return
  return(out[, .(rp, hs, tp)])
}

.find_ht_iso_anchor_points = function(ht, output_rp){
  
  ## Find lap_hs0
  npy = ht$npy
  p_dep_thresh = ht$dep$p_dep_thresh
  p_hs0 = 1-(1/(output_rp*npy))
  if(any(p_hs0<ht$dep$p_dep_thresh)){
    warning("Not all output_rp are above the threshold for the Heffernan-Tawn model.")
    warning("Those below the threshold will be ignored.")
    warning("Increase the argument dep_thresh_count in function fit_ht, or adjust the output RP for the
            contours.")
  }
  keep_idx = which(p_hs0>=p_dep_thresh)
  lap_hs0 = -log(2*(1-p_hs0))[keep_idx]
  p_hs0 = p_hs0[keep_idx]
  output_rp = output_rp[keep_idx]
  
  ## Find median lap_tp0 given lap_hs0
  dep_par = ht$dep$hs$par
  dep_median_resid = median(ht$dep$hs$resid)
  lap_tp0 = lap_hs0*dep_par[["a"]]+dep_median_resid*lap_hs0^dep_par[["b"]]
  p_tp0 = 1-exp(-abs(lap_tp0))/2
  
  ## Find hs0
  hs0_calc = data.table(p = p_hs0, p_gpd = (p_hs0-ht$margin$p_margin_thresh)/(1-ht$margin$p_margin_thresh))
  hs_par = ht$margin$hs$par
  hs0_calc[p_gpd<1 & p_gpd>0, hs0:= qgpd(
    p_gpd, loc=hs_par[["loc"]], scale = hs_par[["scale"]], shape = hs_par[["shape"]])]
  
  ## Find tp0
  tp0_calc = data.table(p = p_tp0, p_gpd = (p_tp0-ht$margin$p_margin_thresh)/(1-ht$margin$p_margin_thresh))
  tp0_calc[, tp0:=quantile(ht$dep$dep_data$tp, p)]
  if(tp0_calc[p_gpd<1 & p_gpd>0, .N]>0){
    tp_par = ht$margin$tp$par
    tp0_calc[p_gpd<1 & p_gpd>0, tp0:= qgpd(
      p_gpd, loc=tp_par[["loc"]], scale = tp_par[["scale"]], shape = tp_par[["shape"]])]
  }
  
  ## Estimate density
  out = data.table(rp=output_rp, hs0=hs0_calc$hs0, tp0=tp0_calc$tp0, lap_hs0 = lap_hs0, lap_tp0 = lap_tp0)
  setkey(out, lap_hs0, lap_tp0)
  ld_calc = .ld_ht(dt_lap = out[, .(lap_hs=lap_hs0, lap_tp=lap_tp0)], ht = ht)
  out[, ld:=ld_calc$ld]
  
  ## Return
  return(out[, .(rp, hs0, tp0, ld)])
}


.ld_ht = function(dt_lap, ht){
  calc = copy(dt_lap)
  lap_thresh = -log(2-2*ht$dep$p_dep_thresh)
  out = list()
  for(cond_var in c("hs","tp")){
    dep_var = setdiff(c("hs", "tp"), cond_var)
    this_resid = ht$dep[[cond_var]]$resid
    this_mu = mean(this_resid)
    this_sigma = sd(this_resid)
    setnames(calc, paste0("lap_", cond_var), "cond_var")
    setnames(calc, paste0("lap_", dep_var), "dep_var")
    
    this_par = ht$dep[[cond_var]]$par
    calc[cond_var>=lap_thresh, resid:=(dep_var-this_par[["a"]]*dep_var)/(cond_var^this_par[["b"]])]
    calc[cond_var>=lap_thresh, ld_resid:=dnorm(resid, mean=this_mu, sd = this_sigma, log = T), .(resid)]
    calc[cond_var>=lap_thresh, ld_dep:=ld_resid-log(cond_var)*this_par[["b"]]]
    calc[cond_var>=lap_thresh, ld_cond:=log(.5)-abs(cond_var)]
    calc[cond_var>=lap_thresh, ld:=ld_cond+ld_dep]
    setnames(calc, "cond_var", paste0("lap_", cond_var))
    setnames(calc, "dep_var", paste0("lap_", dep_var))
    setnames(calc, "ld", paste0("ld_", cond_var))
    out[[cond_var]] = calc[, c("lap_hs", "lap_tp", paste0("ld_", cond_var)), with=F]
  }
  
  calc = merge(out[[1]], out[[2]], by=c("lap_hs", "lap_tp"))
  calc[lap_hs<lap_thresh & lap_tp<lap_thresh, ld:=NA_real_]
  calc[lap_hs>=lap_thresh & lap_tp>=lap_thresh, w_hs:= (lap_hs-lap_thresh)/(lap_hs+lap_tp-2*lap_thresh)]
  calc[lap_hs>=lap_thresh & lap_tp>=lap_thresh, w_tp:= 1-w_hs]
  calc[lap_hs>=lap_thresh & lap_tp>=lap_thresh, ld:=ld_hs*w_hs+ld_tp*w_tp]
  calc[lap_hs>=lap_thresh & lap_tp<lap_thresh, ld:=ld_hs]
  calc[lap_hs<lap_thresh & lap_tp>=lap_thresh, ld:=ld_tp]
  return(calc[, .(lap_hs, lap_tp, ld)])
}
