#' Estimating the IFORM contours
#'
#' @description
#' This function estimates the Invserse FORM environmental contours for a 
#' given sample data or a fitted joint distribution of class \code{ht} or \code{wln} object.
#' 
#' @param object either a fitted joint distribution as generated by function \code{\link{fit_ht}}
#' and \code{\link{fit_wln}}, or an existing sample wave data containing \code{hs} and \code{tp} as columns. See details.
#' 
#' @param output_rp the required return periods (in years) for the estimated contours. Note that return periods
#' that are substantially larger than the data coverage may lead to a long processing time
#' 
#' @param npy the (optional) number of data points per year.  This argument is only needed if the input
#' \code{object} is a sample data.
#' 
#' @param n_point the number of points to output around each contour. The default value is 100.
#' 
#' @param alpha0 the omission factor for the IFORM contours, as proposed in Winterstein et al. (1993).
#' The default value is 0, meaning no inflation to the estimated contours.
#' 
#' @details
#' 
#' The function can be applied to an existing sample data. To do this, the user needs
#' to supply both the sample data \code{sample_data} and the corresponding number of data points per year
#' \code{sample_data_npy}. The sample data can be generated using function \code{\link{sample_jdistr}} or otherwise, 
#' but must contain \code{hs} and \code{tp} as columns.  This \code{data.table} can also be generated
#' by reading a CSV file using function \code{\link[data.table]{fread}}.  
#' 
#' Alternatively this function can also be applied to a fitted joint distribution 
#' generated by function \code{\link{fit_ht}} or \code{\link{fit_wln}}.
#' 
#' @return A set of estimated environmental contours with the specified return periods in the format
#' of a \code{data.table} with \code{rp}, \code{hs}, and \code{tp} as columns.
#'
#' @examples
#' # Load data
#' data(ww3_pk)
#' 
#' # Fit the Weibull-log-normal distribution to hs and tp
#' wln = fit_wln(data = ww3_pk, npy = nrow(ww3_pk)/10)
#' 
#' # Estimate the GJE contours using the Hs return levels as 
#' iform = estimate_iform(
#'   object = wln,
#'   output_rp = c(1,10,100),
#'   alpha0 = 0.01)
#'   
#' # Plot output
#' plot_ec(iform, ww3_pk)
#' 
#' @references
#' Winterstein, S. R., Ude, T. C., Cornell, C. A., Bjerager, P., Haver, S., 1993. Environmental parameters
#' for extreme variable: Inverse Form with omission factors. In: Proc. 6th Int. Conf. on
#' Structural Safety and Reliability, Innsbruck, Austria.
#' 
#' @seealso \code{\link{fit_ht}}, \code{\link{fit_wln}}, \code{\link{sample_jdistr}}, \code{\link{plot_ec}}
#' 
#' @export
estimate_iform = function(
  object, output_rp, npy = NULL, n_point=100, alpha0=0){
  
  if("wln" %in% class(object)){
    
    res = .estimate_iform_from_wln(wln = object, output_rp = output_rp, n_point = n_point, alpha0 = alpha0)
    if(!is.null(npy)){
      warning("Argument npy will be imported from the provided joint distribution object.  The supplied npy is ignored.")
    }
    
  }else if("ht" %in% class(object)){
    
    res = .estimate_iform_from_ht(ht = object, output_rp = output_rp, n_point = n_point, alpha0 = alpha0)
    if(!is.null(npy)){
      warning("Argument npy will be imported from the provided joint distribution object.  The supplied npy is ignored.")
    }
    
  }else if("data.table" %in% class(object)){
    
    res = .estimate_iform_from_sample_data(
      sample_data = object, sample_data_npy = npy,
      output_rp = output_rp, n_point = n_point, alpha0 = alpha0)
    
  }else{
    
    stop("The input object must be of class ht, wln or data.table.")
  }
  
  return(res)
}


# Sub functions -----------------------------------------------------------

.estimate_iform_from_sample_data = function(sample_data, sample_data_npy, output_rp, n_point, alpha0){
  
  
  # Calculate beta and inflate
  prob = 1 - 1/(sample_data_npy*output_rp)
  beta = qnorm(prob)
  beta_star = beta / (sqrt(1-(alpha0^2)))
  
  # Define points
  angle = seq(0, 2*pi, length.out = n_point+1)
  calc = data.table(rp = rep(output_rp, each=n_point+1), angle = angle)
  calc[, u1:=rep(beta_star, each=n_point+1)*cos(angle)]
  calc[, u2:=rep(beta_star, each=n_point+1)*sin(angle)]
  calc[, p1:=pnorm(u1)]
  calc[, p2:=pnorm(u2)]
  calc[, hs:=quantile(sample_data$hs, p1, names = F)]
  
  for(i in 1:calc[, .N]){
    cond_distr_bw = calc[rp==calc[i]$rp, bw.SJ(hs)]
    td_data = sample_data[abs(hs-calc$hs[i])<=cond_distr_bw/2]
    if(td_data[,.N]<.knn){
      td_data = sample_data[sort.list(abs(hs-calc$hs[i]))[1:.knn]]
    }
    calc[i, tp:=quantile(td_data$tp, p2, names = F)]
  }
  
  # Return
  res = calc[, .(rp, hs, tp)]
  return(res)
}


.estimate_iform_from_wln = function(wln, output_rp, n_point, alpha0){
  
  # Calculate beta and inflate
  prob = 1 - 1/(wln$npy*output_rp)
  beta = qnorm(prob)
  beta_star = beta / (sqrt(1-(alpha0^2)))
  
  # Define points
  angle = seq(0, 2*pi, length.out = n_point+1)
  calc = data.table(rp = rep(output_rp, each=n_point+1), angle = angle)
  calc[, u1:=rep(beta_star, each=n_point+1)*cos(angle)]
  calc[, u2:=rep(beta_star, each=n_point+1)*sin(angle)]
  calc[, p1:=pnorm(u1)]
  calc[, p2:=pnorm(u2)]
  calc[, hs:=qweibull(p1, shape=wln$hs$par["shape"], scale=wln$hs$par["scale"])+wln$hs$par["loc"]]
  calc[, m:=wln$tp$par[1] + wln$tp$par[2] * (hs ^ wln$tp$par[3])]
  calc[, v:=wln$tp$par[4] + wln$tp$par[5] * exp(wln$tp$par[6] * hs)]
  calc[, tp:=qlnorm(p2, m, sqrt(v))]
  
  # Return
  res = calc[, .(rp, hs, tp)]
  return(res)
}

.estimate_iform_from_ht = function(ht, output_rp, n_point, alpha0){
  
  p_thresh = ht$margin$p_margin_thresh
  n_exceed = length(ht$margin$hs$emp)*(1-p_thresh)
  
  # Calculate beta and inflate
  prob = 1 - 1/(ht$npy*output_rp)
  beta = qnorm(prob)
  beta_star = beta / (sqrt(1-(alpha0^2)))
  
  # Define points
  angle = seq(0, 2*pi, length.out = n_point+1)
  calc = data.table(rp = rep(output_rp, each=n_point+1), angle = angle)
  calc[, u1:=rep(beta_star, each=n_point+1)*cos(angle)]
  calc[, u2:=rep(beta_star, each=n_point+1)*sin(angle)]
  calc[, p1:=pnorm(u1)]
  calc[, p2:=pnorm(u2)]


  # Estimate hs based on hs model
  calc_hs = calc[p1>ht$dep$p_dep_thresh]
  calc_hs[p1<p_thresh, hs:=quantile(ht$margin$hs$emp, p1)]
  calc_hs[p1>=p_thresh, hs:=evd::qgpd(
    p = (p1-p_thresh)/(1-p_thresh), loc = ht$margin$hs$par[1],
    scale = ht$margin$hs$par[2], shape = ht$margin$hs$par[3])]
  
  # Estimate tp based on tp|hs HT model for large hs
  calc_hs[p1<0.5, lap1:=log(2*p1)]
  calc_hs[p1>=0.5, lap1:=-log(2-2*p1)]
  # calc_hs[, resid_q:=.get_quantile_with_gpd(
  #   data = ht$dep$hs$resid, p_thresh = 1-n_exceed/length(ht$dep$hs$resid),
  #   output_p = p2, high_only = T)]
  calc_hs[, resid_q:=quantile(ht$dep$hs$resid, p2)]
  calc_hs[,lap2:=ht$dep$hs$par[1]*lap1+resid_q*lap1^ht$dep$hs$par[2]]
  calc_hs[lap2<0, p_tp:=.5*exp(lap2)]
  calc_hs[lap2>=0, p_tp:=1-.5*exp(-lap2)]
  calc_hs[, tp:=quantile(ht$margin$tp$emp, p_tp)]
  calc_hs[p_tp>p_thresh, tp:=evd::qgpd(
    p = (p_tp-p_thresh)/(1-p_thresh), loc = ht$margin$tp$par[1],
    scale = ht$margin$tp$par[2], shape = ht$margin$tp$par[3])]
  
  # Estimate tp based on tp model
  calc_tp = calc[p2>ht$dep$p_dep_thresh]
  calc_tp[p2<p_thresh, tp:=quantile(ht$margin$tp$emp, p2)]
  calc_tp[p2>=p_thresh, tp:=evd::qgpd(
    p = (p2-p_thresh)/(1-p_thresh), loc = ht$margin$tp$par[1],
    scale = ht$margin$tp$par[2], shape = ht$margin$tp$par[3])]
  
  # Estimate hs based on hs|tp HT model for large tp
  calc_tp[p2<0.5, lap2:=log(2*p2)]
  calc_tp[p2>=0.5, lap2:=-log(2-2*p2)]
  # calc_tp[, resid_q:=.get_quantile_with_gpd(
  #   data = ht$dep$tp$resid, p_thresh = 1-n_exceed/length(ht$dep$tp$resid),
  #   output_p = p1, high_only = T)]
  calc_tp[, resid_q:=quantile(ht$dep$tp$resid, p1)]
  calc_tp[,lap1:=ht$dep$tp$par[1]*lap2+resid_q*lap2^ht$dep$tp$par[2]]
  calc_tp[lap1<0, p_hs:=.5*exp(lap1)]
  calc_tp[lap1>=0, p_hs:=1-.5*exp(-lap1)]
  calc_tp[, hs:=quantile(ht$margin$hs$emp, p_hs)]
  calc_tp[p_hs>p_thresh, hs:=evd::qgpd(
    p = (p_hs-p_thresh)/(1-p_thresh), loc = ht$margin$hs$par[1],
    scale = ht$margin$hs$par[2], shape = ht$margin$hs$par[3])]
  
  
  # # Estimate tp based on simulated (hs, tp) for hs | tp for large tp
  # n_sim_year = max(output_rp)*.rp_multiplier
  # sim_tp = .sample_ht1(
  #   n_sim = n_sim_year*ht$npy*(1-ht$dep$p_dep_thresh), par = ht$dep$tp$par,
  #   resid = ht$dep$tp$resid, p_dep_thresh = ht$dep$p_dep_thresh, perturbed_ht_residuals = T)
  # calc_low = calc[p1<=ht$dep$p_dep_thresh]
  # bw_tp = bw.SJ(ht$dep$dep_data$tp)
  # set.seed(.seed_sampling)
  # emp = ht$dep$dep_data[, .(u_hs, tp=tp+rnorm(.N*10,0,bw_tp))]
  # # emp = ht$dep$dep_data[, .(u_hs, tp)]
  # 
  # for(i in 1:nrow(calc_low)){
  #   nn_sample = emp[abs(u_hs-calc_low[i]$p1)<=0.01][sort.list(abs(u_hs-calc_low[i]$p1))[1:min(.N, n_exceed*5)]]$tp
  #   calc_low[i, tp:=.get_quantile_with_gpd(
  #     data = nn_sample, p_thresh = 1-n_exceed/length(nn_sample),
  #     output_p = p2, high_only = F)]
  #   # calc_low[i, tp:=quantile(nn_sample, p2)]
  # }
  
  # Return
  res = merge(
    x = calc_hs[, .(rp, angle, hs, tp)], y = calc_tp[, .(rp, angle, hs, tp)],
    by=c("rp", "angle"), all=T)
  res[is.na(hs.x), hs:=hs.y]
  res[is.na(tp.x), tp:=tp.y]
  res[is.na(hs.y), hs:=hs.x]
  res[is.na(tp.y), tp:=tp.x]
  
  # res[!is.na(hs.x+hs.y), wgt_x:=1-angle/pi*2]
  res[!is.na(hs.x+hs.y), hs:=hs.x*cos(angle)^2+hs.y*sin(angle)^2]
  res[!is.na(hs.x+hs.y), tp:=tp.x*cos(angle)^2+tp.y*sin(angle)^2]
  setkey(res, rp, angle)
  return(res[, .(rp, hs, tp)])
}

.get_quantile_with_gpd = function(data, p_thresh, output_p, high_only=TRUE){
  calc = data.table(output_p=output_p, value=quantile(data, output_p))
  if(any(output_p>p_thresh)){
    pot_high = evd::fpot(x = data, threshold = quantile(data, p_thresh), cmax = F, std.err = F)
    calc[output_p>p_thresh, value:=evd::qgpd(
      p = (output_p-p_thresh)/(1-p_thresh), loc = pot_high$threshold,
      scale = pot_high$estimate[1], shape = pot_high$estimate[2])]
  }
  if(any(output_p<1-p_thresh)&&(!high_only)){
    pot_low = evd::fpot(x = -data, threshold = quantile(-data, p_thresh), cmax = F, std.err = F)
    calc[output_p<1-p_thresh, value:=-evd::qgpd(
      p = (1-output_p-p_thresh)/(1-p_thresh), loc = pot_low$threshold,
      scale = pot_low$estimate[1], shape = pot_low$estimate[2])]
  }
  return(calc$value)
}
